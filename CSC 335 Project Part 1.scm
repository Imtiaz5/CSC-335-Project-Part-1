;Project Done by David and Imtiaz

;In order to abstract and create a higher order function for the divide and conquer paradigm you need to understand the components
;Which include:
;Each of these type of functions must consider a base case
;Have functions to divide the problem into smaller subproblems
;A procedure/function to combine the smaller subproblems to form an answer
;As well as the problem we are solving

;The difficulty is just setting up how these functions and procedures are passed
(define (divide-and-conquer division-1 division-2 base-case conquer problem)
  (cond ((base-case problem) problem)
        (else (let ((sub-problem-1 (division-1 problem))
                    (sub-problem-2 (division-2 problem)))
        (conquer 
         (divide-and-conquer division-1 division-2 base-case conquer sub-problem-1)
         (divide-and-conquer division-1 division-2 base-case conquer sub-problem-2))))))

;The structure is simple- a conditional and an else statement
;Once the condition is fufilled we return problem we are manipulating

;The let, in the else statement is where two subproblems are created by calling the division functions
;division-1 will create the first subproblem division-2  will create the second subproblem
;conquer is the procedure for which the two subproblems will eventually put together
;within the conquer function, divide-and-conquer is called for the first subproblem and then the second subproblem


;precondition:
;Two functions must be provided to create the subproblems, this consititutes the first two parameters
;A base case function that checks for the base cases you need and returns a truth value, this constitutes the third parameter
;the function that will combine the subproblems, this consitutes the fourth parameter
;the last parameter is the problem you are to solve; list, number, ect. constitutes the fifth parameter

;post-condition:
;recursively applies your given parameters returns a solved solution for the problem based on the parameters presented

;IH: Given a problem, we can split the problem into two easier to solve subproblems.Using the functions provided.
;given that those subproblems can be solved using the conquer function paramter, the main problem can be solved using the conquer parameter.

;IS: Combining the correct solutions from the recursive calls using 'combine-fn' yields a valid solution for the larger, original problem

;Base case: whatever the user sets to return a subset of the problem

;Termination argument: The 'divide-and-conquer' function will terminate when the base case is reached,
;since we will assume that the sub problems generated by 'division-1' and 'division-2' functions will eventually lead to a base case
;without any necessary sub-division

;Stopping Condition: Once the Base case has been reached 



;to see how this works we will look at merge-sort:
;starting with the division functions
(define (even-in lst)
  (cond ((null? lst) '())
        ((null? (cdr lst)) (cons (car lst) '()))
        (else (cons(car lst) (even-in (cdr(cdr lst)))))))

(define (odd-in lst)
  (cond ((null? lst) '())
        ((null? (cdr lst)) '())
        (else (cons(car (cdr lst)) (odd-in (cdr(cdr lst)))))))

;these functions go through a given list and return a list with even indexed elements and odd indexed elements
;which refers to this:
;(1 2 3 4 5 6)
;(0 1 2 3 4 5) <- index
;(1 3 5) <- even index
;(2 4 6) <- odd index
;essentially breaking a large problem into smaller sub problems

;as for the base-case it is necesarry they return a #f or #t
(define (mergesort-base-case lst)
  (or (null? lst) (null? (cdr lst))))
;they will only return true if either condition is true

;now for the conquer part of merge sort, merge
(define (merge left right)
  (cond ((null? left) right)
        ((null? right) left)
        (else
          (if (< (car left) (car right))
              (cons (car left) (merge (cdr left) right))
              (cons (car right) (merge left (cdr right)))))))
;this puts the subproblems togther

;note that in this case it does not matter which subproblem is created first 
;given this problem
(define list-test '(2 5 2 3 9 6 1 8 7 4))

(display "merge-sort solution:") (newline)
(divide-and-conquer even-in odd-in mergesort-base-case merge list-test)


;here are the divison functions for quicksort
(define (partition-less lst pivot less-than) 
  (if (null? lst)
      less-than
      (let ((current (car lst))
            (rest (cdr lst)))
        (if (< current pivot)
            (partition-less rest pivot (cons current less-than))
            (partition-less rest pivot less-than)))))
;we start off with the partiton elements that are less than the piviot

;here's the function which determines if the partition element is greater-than or equal to the pivot
(define (partition-greater lst pivot greater-than)
  (if (null? lst)
      greater-than
      (let ((current (car lst))
            (rest (cdr lst)))
        (if (>= current pivot) 
            (partition-greater rest pivot (cons current greater-than))
            (partition-greater rest pivot greater-than)))))

;these functions will go through a list and will return lists that are either
;less than the piviot and greater than or equal to the given pivot:
;(3 1 4 1 5 9 2 6 5 3 5) <- List
;5 <- Pivot
;'() <- less-than and greater-than
; (partition-less '(3 1 4 1 2 3) 5 '()): (3 1 4 1 2 3) <- Returns a list of numbers less than the pivot
; (partition-greater '(3 1 4 1 2 3) 5 '()): (5 9 6 5 5) <- Returns a list of numbers greater than or equal to the pivot

;continuing with our division function, we use the partition functions and use it here for our main divide function
(define (quick-sort-divide1 lst)
  (let ((pivot (car lst)))
    (partition-greater lst pivot '())))

(define (quick-sort-divide2 lst)
  (let ((pivot (car lst)))
    (partition-less lst pivot '())))
;here we are making pivot the first element of our list so that our function will work properly when we call it
;note** we need to define another function other than (partition-greater&partition-less) to initialize the values we need

;(3 1 4 1 5 9 2 6 5 3 5) <- List
;(quick-sort-divide1 '(3 1 4 1 5 9 2 6 5 3 5)): (5 3 5 6 9 5 4 3)
;returned the list of numbers that are greater than or equal to 3
;(quick-sort-divide2 '(3 1 4 1 5 9 2 6 5 3 5)): (2 1 1)
;return the list of numbers that are less than 3

;this function determines our base case
(define (quicksort-base-case lst)
  (or (null? lst) (null? (cdr lst)) (allc lst)))
;if we get a empty list or if the next element is empty, we will call the function allc

;The function allc will check if all the elements in the list are equal to each other
(define (allc lst)
  (cond ((null? (cdr lst)) #t)
        (else (and (eq? (car lst) (car (cdr lst))) (allc (cdr lst))))))

;This function appends the first element of the list to the rest of the list
(define (my-append n m) 
  (cond ((null? n) m)
        (else (cons (car n) (my-append (cdr n) m)))))

;this is where the conquer part comes into play for quicksort, which is called quicksort-combine
(define (quicksort-combine n m)
    (cond ((null? n) m)
          (else (cons (car n) (my-append (cdr n) m)))))
;uses my-append to combine the subproblems together

(display "quick-sort solution:") (newline)
(divide-and-conquer quick-sort-divide2 quick-sort-divide1 quicksort-base-case quicksort-combine list-test)

;*note that quick-sort-divide2 is before quick-sort-divide1 that is because we need the less partition to append to the greater-equal partition


